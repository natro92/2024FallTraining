<h1 id="RSqBv">一、base64编码</h1>
base64是一种编码方式，非常显然的~~废话文学~~

这<font style="color:rgb(26, 32, 41);">是一种基于64个可打印字符来表示二进制数据的表示方法。它常用于在那些只允许使用ASCII字符的媒体中存储和传输数据，例如在电子邮件协议中对二进制文件的传输，初衷之一似乎并非为了加密而是为了正确显示所有字符（因为一些字符不可打印）</font>

> <font style="color:rgb(26, 32, 41);">base是一种基于64个可打印字符来表示二进制数据的表示方法。由于2的6次方等于64，所以每6个比特为一个单元，对应某个可打印字符。3个字节有24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。它可用来作为电子邮件的传输编码。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。</font>
>
> <font style="color:rgb(77, 77, 77);">在不同的实现中，Base64算法中由64个字符组成的字符集是不一样的。但是通常的实现方法是选择64个通用且能打印的字符来组成这样一个集合。且要保证这个集合中的每个字符组成的数据在数据传输系统中不会被修改。</font>
>

<font style="color:rgb(77, 77, 77);">以一段文字为例</font>

<font style="color:rgb(77, 77, 77);">Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.</font>

<font style="color:rgb(77, 77, 77);">丢到cyberchef里面炒一下</font>

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1733161558443-aba265f6-e8fb-476f-bf81-f2774f49db06.png)

<font style="color:rgb(77, 77, 77);"></font>

首先，我们发现字符串“Man”的Base64编码是“TWFu”，那么这是怎么转换过来的呢？不急，我们一个一个字符来分析，首先对于“M”来说，"M"对应的ASCII编码是77，二进制形式即01001101；同理，字符“a”对应的ASCII编码是97，二进制表现形式为01100001；“n”的ASCII编码为110，二进制形式为：01101110。这三个字符的二进制位组合在一起就变成了一个24位的字符串“010011010110000101101110”，接下来，我们从左至右，每次抽取6位作为1组（因为6位一共有2^6=64种不同的组合），因此每一组的6位又代表一个数字（0~63），接下来，我们查看索引表，找到这个数字对应的字符，就是我们最后的结果

24位字符串：“010011010110000101101110”的第一组6位数是“010011”，对应的十进制数是19，我们查找索引表发现，19对应的字符是“T”，因此，第一组6位数对应的字符就是“T”；同理，第二组6位数是“010110”，对应的十进制数是22，查找索引表，22对应的字符是“W”；同理，第三组6位数是“000101”，对应的十进制是5，查表得，5对应的字符是“F”；同理，第四组6位数是“101110”，对应的十进制是46，查表得，46对应的字符是“F”。到此，“Man”字符串的编码就完成了，不相信的同学可以去上述的Base64在线加密网站亲自试一试。我们发现，3个ASCII字符，一共24位，最后编码成了4个ASCII字符，32位。因此，从24位到32位的转变，使得Base64编码的结果要比原来的值变得更大，且大1/3。因此，Base64编码实质上就是把一个个24比特位组成的二进制组合转换成32比特位组成的二进制组合，其中，缺位用0填充，缺了一整组则用“=”填充;在实战中字母表的顺序也可以变化，具体看实际情况而定

由此我们可以得出base64编码的几个特点：

1.编码后的大小比原来大三分之一（具体原因如上

2.程序内含有一个字母表用于储存编码方式

3.程序中会有/3和*4的部分作为标识（原因同上，编码方式导致的

由此我们可以比较轻松地识别base64编码

<h1 id="kEnhR">二、.so文件是什么，如何食用</h1>
.so文件在我看来是一个很奇怪的东西

明明主要是由java编写的安卓程序却有需要用C语言逆向的且在程序内部举足轻重的文件，显然是一件非常奇怪的事情，那么.so文件究竟是为什么存在呢？

开发Android应用时，有时候Java层的编码不能满足实现需求，就需要到C/C++实现后生成SO文件，再用System.loadLibrary()加载进行调用，这里成为JNI层的实现。常见的场景如：加解密算法，音视频编解码等。在生成SO文件时，需要考虑适配市面上不同手机CPU架构，而生成支持不同平台的SO文件进行兼容。目前Android共支持七种不同类型的CPU架构，分别是：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)。

因此用途主要是兼容各个型号的手机（

<h1 id="VBisd">三、断点是什么，为什么要下断点</h1>
<font style="color:rgb(77, 77, 77);">断点是调试器设置源程序在执行过程中自动进入中断模式的一个标记。当程序运行到断点时，程序中断执行，进入调试状态</font>

<font style="color:rgb(77, 77, 77);">简而言之，是一种用于动态调试的方式</font>

<font style="color:rgb(77, 77, 77);">以实例来举例的话，以之前week3的手动脱壳为例，esp法会在寄存器处下断点，在程序自解密或者自解压过程中, 不少壳会先将当前寄存器状态压栈, 如使用pushad, 在解压结束后, 会将之前的寄存器值出栈, 如使用popad. 因此在寄存器出栈时, 往往程序代码被恢复, 此时硬件断点触发. 然后在程序当前位置, 只需要少许单步操作, 就很容易到达正确的 OEP 位置，这里用断点中断程序执行的方式抓住寄存器出栈的点来抓住oep的位置</font>

<font style="color:rgb(77, 77, 77);">如这周的一道反调试的题目中，也可以使用下断点后动态调试逐步执行的方式来使得数组中出现预设值（即使在初始预设值并不存在的情况下</font>

<h1 id="YN6S0"><font style="color:rgb(77, 77, 77);">四、本周Dirty Flowers的花为什么要这么去</font></h1>
本周的Dirty Flower中花的形式是比较基础的call $+5 pop形式，

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1733225627473-744b9517-6c0d-49a5-b76e-29394abd725e.png)

简单分析一下代码可以得知，这里call$+5的地址（即4012F7）正好是pop的位置

根据官方WP给的思路复现一下栈帧操作，可得这里的花原理为<font style="color:rgb(77, 77, 77);">用pop的方式来清除call的压栈，使栈平衡。</font>从而用call实现jmp。IDA会认为call的目标地址为函数起始地址，导致函数创建错误，无法正常读取,故而无法f5进入反编译。

<h1 id="wwg7r">五、AES算法</h1>
高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法

对称加密算法意为加密与解密用同一个密钥，与之对应的为非对称加密

非对称加密有两个密钥,这两者之间的区别在week1用hexo搭过blog的同学应该知道，在中间申请sshkey的那一步时会发下来两个文件，

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1733226976533-7d96e93d-726b-46a5-af63-4775a1d787f5.png)

，这个pub并非意为microsoft'的publisher文件,而是public公钥的意思,与之对应的是私钥,简单来说非对称加密的文件中用公钥加密的文件只能用私钥解密,用私钥加密的本地文件也只能用公钥解密

而此处的对称加密则为使用同一个密钥加密与解密, 通常形式为C = E(K, P),其中P为明文，K为密钥，C为密文。也就是说，把明文P和密钥K作为加密函数的参数输入，则加密函数E会输出密文C;同理设AES解密函数为D，则 P = D(K, C),其中C为密文，K为密钥，P为明文。也就是说，把密文C和密钥K作为解密函数的参数输入，则解密函数会输出明文P。

落实到AES上,AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同,具体加密轮数如下所示

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1733227366877-68505bfd-6d5f-4f5b-b4b2-d45238090b90.png)

具体流程为:

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1733227397619-1ea36f14-f820-48a8-aae5-53dff6fe5e20.png)

<h2 id="mGeXH">一、字节代换</h2>
这次逆向作业中出现相当多次的sbox就是这玩意,其中分为s盒和逆s盒

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1733227516941-80dcf74d-0123-43d5-bbcd-72b33bbc881b.png)

状态矩阵中的元素按照下面的方式映射为一个新的字节：把该字节的高4位作为行值，低4位作为列值，取出S盒或者逆S盒中对应的行的元素作为输出。例如，加密时，输出的字节S1为0x12,则查S盒的第0x01行和0x02列，得到值0xc9,然后替换S1原有的0x12为0xc9。状态矩阵经字节代换后的图如下：

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1733227594029-47da941c-e6ed-4720-8645-f87bd4829b9d.png)

同理逆S盒:![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1733227576843-7c853bd8-b733-499e-8266-24d2b30d1129.png)

与s盒相同,通过查逆s盒来代换

<h2 id="eE23A">二、行移位</h2>
是一个简单的左循环移位操作。当密钥长度为128比特时，状态矩阵的第0行左移0字节，第1行左移1字节，第2行左移2字节，第3行左移3字节

逆向操作改为右移即可

<h2 id="EhS2T">三、列混合</h2>
列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1733227804321-5d4d981d-9ab1-484e-a176-2ad68aa44fbf.png)

状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1733227852065-5ad34c49-e360-4722-ab9f-e574ea076d6a.png)

其中，矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算,并不是通常意义上的乘法和加法。这里涉及到一些信息安全上的数学知识，不过不懂这些知识也行。其实这种二元运算的加法等价于两个字节的异或，乘法则复杂一点。对于一个8位的二进制数来说，使用域上的乘法乘以(00000010)等价于左移1位(低位补0)后，再根据情况同(00011011)进行异或运算

<h2 id="IZoJM">四、轮密钥加</h2>
轮密钥加是将128位轮密钥Ki同状态矩阵中的数据进行逐位异或操作，如下图所示。其中，密钥Ki中每个字W[4i],W[4i+1],W[4i+2],W[4i+3]为32位比特字，包含4个字节，他们的生成算法下面在下面介绍。轮密钥加过程可以看成是字逐位异或的结果，也可以看成字节级别或者位级别的操作。也就是说，可以看成S0 S1 S2 S3 组成的32位字与W[4i]的异或运算。

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1733227967280-bcedce93-54e7-4cd9-8044-0a5b8912aba9.png)

值得一提的是,由于xor运算的结合律,这一步加密与解密完全相同

<h2 id="ofvBI">五、密钥扩展</h2>
AES首先将初始密钥输入到一个44的状态矩阵中，如下图所示。

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1733228061802-7891bc54-59fd-4ba9-890a-b0e160626237.png)

这个44矩阵的每一列的4个字节组成一个字，矩阵4列的4个字依次命名为W[0]、W[1]、W[2]和W[3]，它们构成一个以字为单位的数组W。例如，设密钥K为"abcdefghijklmnop",则K0 = ‘a’,K1 = ‘b’, K2 = ‘c’,K3 = ‘d’,W[0] = “abcd”。

接着，对W数组扩充40个新列，构成总共44列的扩展密钥数组。新列以如下的递归方式产生：

1.如果i不是4的倍数，那么第i列由如下等式确定：

W[i]=W[i-4]⨁W[i-1]

2.如果i是4的倍数，那么第i列由如下等式确定：

W[i]=W[i-4]⨁T(W[i-1])

其中，T是一个有点复杂的函数。

函数T由3部分组成：字循环、字节代换和轮常量异或，这3部分的作用分别如下。

a.字循环：将1个字中的4个字节循环左移1个字节。即将输入字[b0, b1, b2, b3]变换成[b1,b2,b3,b0]。

b.字节代换：对字循环的结果使用S盒进行字节代换。

c.轮常量异或：将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。

轮常量Rcon[j]是一个字，其值见下表：

![](https://cdn.nlark.com/yuque/0/2024/png/50154293/1733228092469-a4683aad-7016-4170-be2d-bc0f33c55b3f.png)

同理也可得逆向求解的方法了，总而言之，遇到AES的题目还是主要找到密钥和具体AES标准两项参数以进一步确定解密代码怎么写（









